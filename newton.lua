
dofile(fractalmap.mod_path.."/complex_manip.lua")

-- Function called just after the chunk is generated by Minest
function fractalmap.generate(minp, maxp, seed, regen)
	--only for plane 0
	if (minp.y>0 or maxp.y<-300) then 
		return
	end

	-- Clay patterns:
	materials={'bakedclay:dark_green','bakedclay:brown','bakedclay:grey','bakedclay:black','bakedclay:white','bakedclay:cyan','bakedclay:orange'}	
	-- Usefull block patterns:
--	materials={'default:dirt_with_grass','default:tree','default:stone','default:cactus','default:stone_with_coal','default:stone_with_iron','default:stone_with_gold','default:stone_with_diamond'}
	
	-- Prepare the block data for the squares
	fractalmap.blocks={}
	for i,val in pairs(materials) do
		fractalmap.blocks[i-1]=minetest.get_content_id(val)
	end


	-- http://www.mitchr.me/SS/newton/
	local MaxCount = 256
	--local MultCol  = 15
	local Tol      = .0001	
	local r1=complex.new(1, 0)
	local r2=complex.new(-1/2, math.sin(2*math.pi/3))
	local r3=complex.new(-1/2, -math.sin(2*math.pi/3))

	local vm,emin,emax
	local blocks={}
	if regen then
		vm = minetest.get_voxel_manip()
		emin, emax = vm:read_from_map(minp, maxp)
	else
		vm, emin, emax = minetest.get_mapgen_object("voxelmanip")
	end
	
	--Get the current data from this chunk
	local data = vm:get_data()
	local area = VoxelArea:new{MinEdge=emin, MaxEdge=emax}

	-- For all x and z in the chunk
	for z = minp.z, maxp.z do
		for x = minp.x, maxp.x do
			h=0
			
			p = complex.new(x/100, z/100)
			local  count = 0;
			while((count < MaxCount) and (complex.abs(complex.sub(p,r1)) >= Tol) and (complex.abs(complex.sub(p,r2)) >= Tol) and (complex.abs(complex.sub(p,r3)) >= Tol)) do
				if(complex.abs(p) > 0) then
					--z = z-(z*z*z-1.0)/(z*z*3.0);
					local p2=complex.mul (p, p);
					local p3=complex.mul (p2, p);
					p = complex.sub(p,   complex.div( complex.sub(p3,complex.new(1, 0)) , complex.mul(complex.new(3, 0),p2) )  )
				end
			count=count+1
			end

			c=0
	      if(complex.abs(complex.sub(p,r1)) < Tol) then
                --h=count
						c=1
         elseif(complex.abs(complex.sub(p,r2)) < Tol) then
                c=2
         elseif(complex.abs(complex.sub(p,r3)) < Tol) then
                c=3
         end
		h=count
		-- create holes
		start=minp.y
		stop=math.min(-h,maxp.y)
			
			-- Put the actual blocks (for the entire chunnk in the data
			for y=start, stop do
				local vi = area:index(x, y, z) 
				data[vi] = fractalmap.blocks[c]
			end
		end
		
	end
	
	-- set the data and do a bunch of updates to the map (copied from yappy)
	vm:set_data(data)
	if regen then
		vm:set_param2_data({})
	end
	if not regen then
		vm:set_lighting({day=0, night=0})
	end
	vm:calc_lighting()
	vm:write_to_map(data)
	vm:update_liquids()
	if regen then
		vm:update_map()
	end
	--minetest.log("action", log_message)
end

